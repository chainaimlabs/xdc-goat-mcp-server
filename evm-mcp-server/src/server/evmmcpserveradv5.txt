async function addRWATools(server: any, walletClient: any, publicClient: any, chain: any, account: any) {
    // Mint ERC3643 Security Token (RWA)
    server.tool(
        "mint_erc3643_security_token",
        {
            tokenAddress: z.string().describe("ERC3643 security token address"),
            to: z.string().describe("Recipient address (must be verified)"),
            amount: z.string().describe("Amount to mint"),
            kycData: z.string().optional().describe("KYC verification data")
        },
        async (args: { tokenAddress: string; to: string; amount: string; kycData?: string }) => {
            try {
                // First check if recipient is verified
                const isVerified = await publicClient.readContract({
                    address:// src/server/evm-advanced-v3.ts - Advanced EVM MCP Server v3 with NFT, DeFi & RWA

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createWalletClient, http, createPublicClient, parseEther, formatEther, parseUnits, formatUnits, encodeFunctionData, decodeFunctionResult } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { mainnet, base, arbitrum, polygon, optimism, baseSepolia } from "viem/chains";
import { z } from "zod";

// Available networks
const NETWORKS = {
    ethereum: mainnet,
    base: base,
    arbitrum: arbitrum,
    polygon: polygon,
    optimism: optimism,
    'base-sepolia': baseSepolia,
};

// Create the advanced MCP server
const server = new McpServer({
    name: "advanced-evm-v3-server",
    version: "3.0.0",
});

// ERC20 ABI
const ERC20_ABI = [
    { constant: true, inputs: [{ name: "_owner", type: "address" }], name: "balanceOf", outputs: [{ name: "balance", type: "uint256" }], type: "function" },
    { constant: false, inputs: [{ name: "_to", type: "address" }, { name: "_value", type: "uint256" }], name: "transfer", outputs: [{ name: "", type: "bool" }], type: "function" },
    { constant: true, inputs: [], name: "decimals", outputs: [{ name: "", type: "uint8" }], type: "function" },
    { constant: true, inputs: [], name: "symbol", outputs: [{ name: "", type: "string" }], type: "function" },
    { constant: true, inputs: [], name: "name", outputs: [{ name: "", type: "string" }], type: "function" },
    { constant: true, inputs: [], name: "totalSupply", outputs: [{ name: "", type: "uint256" }], type: "function" },
] as const;

// ERC721 (NFT) ABI
const ERC721_ABI = [
    { constant: true, inputs: [{ name: "_owner", type: "address" }], name: "balanceOf", outputs: [{ name: "", type: "uint256" }], type: "function" },
    { constant: true, inputs: [{ name: "_tokenId", type: "uint256" }], name: "ownerOf", outputs: [{ name: "", type: "address" }], type: "function" },
    { constant: false, inputs: [{ name: "_from", type: "address" }, { name: "_to", type: "address" }, { name: "_tokenId", type: "uint256" }], name: "transferFrom", outputs: [], type: "function" },
    { constant: true, inputs: [{ name: "_tokenId", type: "uint256" }], name: "tokenURI", outputs: [{ name: "", type: "string" }], type: "function" },
    { constant: true, inputs: [], name: "name", outputs: [{ name: "", type: "string" }], type: "function" },
    { constant: true, inputs: [], name: "symbol", outputs: [{ name: "", type: "string" }], type: "function" },
    { constant: true, inputs: [], name: "totalSupply", outputs: [{ name: "", type: "uint256" }], type: "function" },
    { constant: false, inputs: [{ name: "_to", type: "address" }, { name: "_tokenId", type: "uint256" }], name: "approve", outputs: [], type: "function" },
    { constant: false, inputs: [{ name: "_operator", type: "address" }, { name: "_approved", type: "bool" }], name: "setApprovalForAll", outputs: [], type: "function" },
] as const;

// ERC1155 (Multi-Token) ABI
const ERC1155_ABI = [
    { constant: true, inputs: [{ name: "_owner", type: "address" }, { name: "_id", type: "uint256" }], name: "balanceOf", outputs: [{ name: "", type: "uint256" }], type: "function" },
    { constant: true, inputs: [{ name: "_owners", type: "address[]" }, { name: "_ids", type: "uint256[]" }], name: "balanceOfBatch", outputs: [{ name: "", type: "uint256[]" }], type: "function" },
    { constant: false, inputs: [{ name: "_from", type: "address" }, { name: "_to", type: "address" }, { name: "_id", type: "uint256" }, { name: "_amount", type: "uint256" }, { name: "_data", type: "bytes" }], name: "safeTransferFrom", outputs: [], type: "function" },
    { constant: true, inputs: [{ name: "_id", type: "uint256" }], name: "uri", outputs: [{ name: "", type: "string" }], type: "function" },
    { constant: false, inputs: [{ name: "_operator", type: "address" }, { name: "_approved", type: "bool" }], name: "setApprovalForAll", outputs: [], type: "function" },
] as const;

// ERC3643 (T-REX Security Token) ABI - Simplified
const ERC3643_ABI = [
    { constant: true, inputs: [{ name: "_userAddress", type: "address" }], name: "isVerified", outputs: [{ name: "", type: "bool" }], type: "function" },
    { constant: true, inputs: [], name: "identityRegistry", outputs: [{ name: "", type: "address" }], type: "function" },
    { constant: true, inputs: [], name: "compliance", outputs: [{ name: "", type: "address" }], type: "function" },
    { constant: false, inputs: [{ name: "_to", type: "address" }, { name: "_amount", type: "uint256" }], name: "transfer", outputs: [{ name: "", type: "bool" }], type: "function" },
    { constant: true, inputs: [{ name: "_from", type: "address" }, { name: "_to", type: "address" }, { name: "_amount", type: "uint256" }], name: "canTransfer", outputs: [{ name: "", type: "bool" }], type: "function" },
] as const;

// ERC6960 (Dual Layer Token) ABI - Simplified
const ERC6960_ABI = [
    { constant: true, inputs: [{ name: "_account", type: "address" }], name: "balanceOf", outputs: [{ name: "", type: "uint256" }], type: "function" },
    { constant: true, inputs: [{ name: "_account", type: "address" }], name: "anchorBalanceOf", outputs: [{ name: "", type: "uint256" }], type: "function" },
    { constant: false, inputs: [{ name: "_amount", type: "uint256" }], name: "anchor", outputs: [], type: "function" },
    { constant: false, inputs: [{ name: "_amount", type: "uint256" }], name: "weigh", outputs: [], type: "function" },
    { constant: true, inputs: [], name: "totalAnchored", outputs: [{ name: "", type: "uint256" }], type: "function" },
] as const;

// Uniswap V3 Pool ABI - Simplified for price queries
const UNISWAP_V3_POOL_ABI = [
    { constant: true, inputs: [], name: "slot0", outputs: [{ name: "sqrtPriceX96", type: "uint160" }, { name: "tick", type: "int24" }, { name: "observationIndex", type: "uint16" }, { name: "observationCardinality", type: "uint16" }, { name: "observationCardinalityNext", type: "uint16" }, { name: "feeProtocol", type: "uint8" }, { name: "unlocked", type: "bool" }], type: "function" },
    { constant: true, inputs: [], name: "liquidity", outputs: [{ name: "", type: "uint128" }], type: "function" },
    { constant: true, inputs: [], name: "token0", outputs: [{ name: "", type: "address" }], type: "function" },
    { constant: true, inputs: [], name: "token1", outputs: [{ name: "", type: "address" }], type: "function" },
    { constant: true, inputs: [], name: "fee", outputs: [{ name: "", type: "uint24" }], type: "function" },
] as const;

async function setupAdvancedEVMv3Tools() {
    try {
        if (!process.env.WALLET_PRIVATE_KEY) {
            throw new Error("WALLET_PRIVATE_KEY environment variable is required");
        }

        const networkName = (process.env.NETWORK || 'base-sepolia') as keyof typeof NETWORKS;
        const selectedChain = NETWORKS[networkName];
        
        if (!selectedChain) {
            throw new Error(`Unsupported network: ${networkName}`);
        }

        console.log(`Setting up Advanced EVM v3 tools for ${selectedChain.name} (Chain ID: ${selectedChain.id})`);

        const account = privateKeyToAccount(process.env.WALLET_PRIVATE_KEY as `0x${string}`);
        
        const walletClient = createWalletClient({
            account,
            chain: selectedChain,
            transport: http(),
        });

        const publicClient = createPublicClient({
            chain: selectedChain,
            transport: http(),
        });

        // Add all advanced tools
        await addBasicEVMTools(server, walletClient, publicClient, selectedChain, account);
        await addNFTTools(server, walletClient, publicClient, selectedChain, account);
        await addDeFiTools(server, walletClient, publicClient, selectedChain, account);
        await addRWATools(server, walletClient, publicClient, selectedChain, account);
        await addAdvancedTokenTools(server, walletClient, publicClient, selectedChain, account);

        console.log(`Registered all advanced tools with EVM MCP Server v3`);
    } catch (error) {
        console.error("Error setting up Advanced EVM v3 tools:", error);
        process.exit(1);
    }
}

async function addBasicEVMTools(server: any, walletClient: any, publicClient: any, chain: any, account: any) {
    // Native balance and transfer (same as before)
    server.tool("get_native_balance", { address: z.string().describe("Address to check balance for") },
        async (args: { address: string }) => {
            try {
                const balance = await publicClient.getBalance({ address: args.address as `0x${string}` });
                return { content: [{ type: "text" as const, text: `Native Balance: ${formatEther(balance)} ${chain.nativeCurrency.symbol}` }] };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        });

    server.tool("send_native_token", { to: z.string(), amount: z.string() },
        async (args: { to: string; amount: string }) => {
            try {
                const hash = await walletClient.sendTransaction({ to: args.to as `0x${string}`, value: parseEther(args.amount) });
                return { content: [{ type: "text" as const, text: `Transfer successful! Hash: ${hash}` }] };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        });
}

async function addNFTTools(server: any, walletClient: any, publicClient: any, chain: any, account: any) {
    // ERC721 NFT Tools
    server.tool(
        "get_nft_balance",
        {
            contractAddress: z.string().describe("NFT contract address"),
            ownerAddress: z.string().describe("Owner address")
        },
        async (args: { contractAddress: string; ownerAddress: string }) => {
            try {
                const balance = await publicClient.readContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: ERC721_ABI,
                    functionName: 'balanceOf',
                    args: [args.ownerAddress as `0x${string}`],
                });

                const [name, symbol] = await Promise.all([
                    publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC721_ABI, functionName: 'name' }),
                    publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC721_ABI, functionName: 'symbol' })
                ]);

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ–¼ï¸ NFT Balance:\nðŸ“Š Count: ${balance}\nðŸ·ï¸ Collection: ${name} (${symbol})\nðŸ“ Contract: ${args.contractAddress}\nðŸ‘¤ Owner: ${args.ownerAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting NFT balance: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Mint ERC721 NFT
    server.tool(
        "mint_erc721_nft",
        {
            contractAddress: z.string().describe("NFT contract address"),
            to: z.string().describe("Recipient address"),
            tokenId: z.string().optional().describe("Token ID (if contract requires specific ID)"),
            tokenURI: z.string().optional().describe("Token URI/metadata"),
            mintFunction: z.enum(["mint", "safeMint", "mintTo", "publicMint"]).optional().describe("Mint function name")
        },
        async (args: { contractAddress: string; to: string; tokenId?: string; tokenURI?: string; mintFunction?: string }) => {
            try {
                const functionName = args.mintFunction || "mint";
                let mintArgs: any[] = [args.to as `0x${string}`];
                
                if (args.tokenId) {
                    mintArgs.push(BigInt(args.tokenId));
                }
                if (args.tokenURI) {
                    mintArgs.push(args.tokenURI);
                }

                const MINT_ABI = [
                    { name: functionName, type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "to", type: "address" },
                        ...(args.tokenId ? [{ name: "tokenId", type: "uint256" }] : []),
                        ...(args.tokenURI ? [{ name: "tokenURI", type: "string" }] : [])
                    ], outputs: [] }
                ] as const;

                const hash = await walletClient.writeContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: MINT_ABI,
                    functionName: functionName,
                    args: mintArgs,
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸŽ¨ NFT Minted Successfully!\nðŸ“ Contract: ${args.contractAddress}\nðŸ‘¤ To: ${args.to}\n${args.tokenId ? `ðŸ†” Token ID: ${args.tokenId}\n` : ''}${args.tokenURI ? `ðŸ”— URI: ${args.tokenURI}\n` : ''}ðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error minting NFT: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Batch Mint ERC721 NFTs
    server.tool(
        "batch_mint_erc721",
        {
            contractAddress: z.string().describe("NFT contract address"),
            recipients: z.array(z.string()).describe("Array of recipient addresses"),
            tokenURIs: z.array(z.string()).optional().describe("Array of token URIs"),
            startTokenId: z.string().optional().describe("Starting token ID for batch")
        },
        async (args: { contractAddress: string; recipients: string[]; tokenURIs?: string[]; startTokenId?: string }) => {
            try {
                const BATCH_MINT_ABI = [
                    { name: "batchMint", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "recipients", type: "address[]" },
                        { name: "tokenURIs", type: "string[]" }
                    ], outputs: [] }
                ] as const;

                const recipients = args.recipients.map(addr => addr as `0x${string}`);
                const tokenURIs = args.tokenURIs || args.recipients.map((_, i) => `ipfs://default/${i}`);

                const hash = await walletClient.writeContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: BATCH_MINT_ABI,
                    functionName: "batchMint",
                    args: [recipients, tokenURIs],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸŽ¨ Batch NFT Mint Successful!\nðŸ“ Contract: ${args.contractAddress}\nðŸ‘¥ Recipients: ${args.recipients.length}\nðŸ“ Recipients: ${args.recipients.join(', ')}\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error batch minting NFTs: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Mint ERC1155 Multi-Token
    server.tool(
        "mint_erc1155_token",
        {
            contractAddress: z.string().describe("ERC1155 contract address"),
            to: z.string().describe("Recipient address"),
            tokenId: z.string().describe("Token ID to mint"),
            amount: z.string().describe("Amount to mint"),
            data: z.string().optional().describe("Additional data (hex)")
        },
        async (args: { contractAddress: string; to: string; tokenId: string; amount: string; data?: string }) => {
            try {
                const MINT_1155_ABI = [
                    { name: "mint", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "to", type: "address" },
                        { name: "id", type: "uint256" },
                        { name: "amount", type: "uint256" },
                        { name: "data", type: "bytes" }
                    ], outputs: [] }
                ] as const;

                const hash = await walletClient.writeContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: MINT_1155_ABI,
                    functionName: "mint",
                    args: [
                        args.to as `0x${string}`,
                        BigInt(args.tokenId),
                        BigInt(args.amount),
                        (args.data || '0x') as `0x${string}`
                    ],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸŽ¨ ERC1155 Token Minted!\nðŸ“ Contract: ${args.contractAddress}\nðŸ‘¤ To: ${args.to}\nðŸ†” Token ID: ${args.tokenId}\nðŸ’° Amount: ${args.amount}\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error minting ERC1155: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Create NFT Collection (Deploy ERC721)
    server.tool(
        "deploy_erc721_collection",
        {
            name: z.string().describe("Collection name"),
            symbol: z.string().describe("Collection symbol"),
            baseURI: z.string().optional().describe("Base URI for metadata"),
            maxSupply: z.string().optional().describe("Maximum supply"),
            mintPrice: z.string().optional().describe("Mint price in ETH")
        },
        async (args: { name: string; symbol: string; baseURI?: string; maxSupply?: string; mintPrice?: string }) => {
            try {
                // Basic ERC721 contract bytecode and constructor
                const ERC721_BYTECODE = "0x608060405234801561001057600080fd5b506040516200123838038062001238833981810160405281019061003391906100b9565b8181816000908051906020019061004b92919061007b565b50806001908051906020019061006292919061007b565b505050505050610128565b80805461007790610128565b9004835790505050505050000a165627a7a72305820";
                
                // For demo purposes, we'll show what would be deployed
                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸš€ NFT Collection Deployment (Simulation):\nðŸ·ï¸ Name: ${args.name}\nðŸŽ¯ Symbol: ${args.symbol}\n${args.baseURI ? `ðŸ”— Base URI: ${args.baseURI}\n` : ''}${args.maxSupply ? `ðŸ“Š Max Supply: ${args.maxSupply}\n` : ''}${args.mintPrice ? `ðŸ’° Mint Price: ${args.mintPrice} ETH\n` : ''}âš ï¸ Note: Actual deployment requires contract compilation and deployment gas fees.\nðŸ’¡ Use a framework like Hardhat or Foundry for production deployment.`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error in collection deployment: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Set NFT Metadata
    server.tool(
        "set_nft_metadata",
        {
            contractAddress: z.string().describe("NFT contract address"),
            tokenId: z.string().describe("Token ID"),
            metadataURI: z.string().describe("New metadata URI")
        },
        async (args: { contractAddress: string; tokenId: string; metadataURI: string }) => {
            try {
                const SET_URI_ABI = [
                    { name: "setTokenURI", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "tokenId", type: "uint256" },
                        { name: "tokenURI", type: "string" }
                    ], outputs: [] }
                ] as const;

                const hash = await walletClient.writeContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: SET_URI_ABI,
                    functionName: "setTokenURI",
                    args: [BigInt(args.tokenId), args.metadataURI],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ”„ NFT Metadata Updated!\nðŸ“ Contract: ${args.contractAddress}\nðŸ†” Token ID: ${args.tokenId}\nðŸ”— New URI: ${args.metadataURI}\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error setting metadata: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Get NFT metadata
    server.tool(
        "get_nft_metadata",
        {
            contractAddress: z.string().describe("NFT contract address"),
            tokenId: z.string().describe("Token ID")
        },
        async (args: { contractAddress: string; tokenId: string }) => {
            try {
                const [owner, tokenURI] = await Promise.all([
                    publicClient.readContract({
                        address: args.contractAddress as `0x${string}`,
                        abi: ERC721_ABI,
                        functionName: 'ownerOf',
                        args: [BigInt(args.tokenId)],
                    }),
                    publicClient.readContract({
                        address: args.contractAddress as `0x${string}`,
                        abi: ERC721_ABI,
                        functionName: 'tokenURI',
                        args: [BigInt(args.tokenId)],
                    })
                ]);

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ–¼ï¸ NFT Metadata:\nðŸ†” Token ID: ${args.tokenId}\nðŸ‘¤ Owner: ${owner}\nðŸ”— Token URI: ${tokenURI}\nðŸ“ Contract: ${args.contractAddress}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/token/${args.contractAddress}?a=${args.tokenId}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting NFT metadata: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Transfer NFT
    server.tool(
        "transfer_nft",
        {
            contractAddress: z.string().describe("NFT contract address"),
            to: z.string().describe("Recipient address"),
            tokenId: z.string().describe("Token ID to transfer")
        },
        async (args: { contractAddress: string; to: string; tokenId: string }) => {
            try {
                const hash = await walletClient.writeContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: ERC721_ABI,
                    functionName: 'transferFrom',
                    args: [account.address, args.to as `0x${string}`, BigInt(args.tokenId)],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸš€ NFT Transfer Successful!\nðŸ†” Token ID: ${args.tokenId}\nðŸ“ To: ${args.to}\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error transferring NFT: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // ERC1155 Multi-Token Tools (existing code continues...)
    server.tool(
        "get_erc1155_balance",
        {
            contractAddress: z.string().describe("ERC1155 contract address"),
            ownerAddress: z.string().describe("Owner address"),
            tokenId: z.string().describe("Token ID")
        },
        async (args: { contractAddress: string; ownerAddress: string; tokenId: string }) => {
            try {
                const balance = await publicClient.readContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: ERC1155_ABI,
                    functionName: 'balanceOf',
                    args: [args.ownerAddress as `0x${string}`, BigInt(args.tokenId)],
                });

                const uri = await publicClient.readContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: ERC1155_ABI,
                    functionName: 'uri',
                    args: [BigInt(args.tokenId)],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸŽ¨ ERC1155 Balance:\nðŸ“Š Balance: ${balance}\nðŸ†” Token ID: ${args.tokenId}\nðŸ”— URI: ${uri}\nðŸ“ Contract: ${args.contractAddress}\nðŸ‘¤ Owner: ${args.ownerAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting ERC1155 balance: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    server.tool(
        "transfer_erc1155",
        {
            contractAddress: z.string().describe("ERC1155 contract address"),
            to: z.string().describe("Recipient address"),
            tokenId: z.string().describe("Token ID"),
            amount: z.string().describe("Amount to transfer")
        },
        async (args: { contractAddress: string; to: string; tokenId: string; amount: string }) => {
            try {
                const hash = await walletClient.writeContract({
                    address: args.contractAddress as `0x${string}`,
                    abi: ERC1155_ABI,
                    functionName: 'safeTransferFrom',
                    args: [account.address, args.to as `0x${string}`, BigInt(args.tokenId), BigInt(args.amount), '0x'],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸš€ ERC1155 Transfer Successful!\nðŸ†” Token ID: ${args.tokenId}\nðŸ’° Amount: ${args.amount}\nðŸ“ To: ${args.to}\nðŸ”— Tx Hash: ${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error transferring ERC1155: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // NFT Collection Analytics
    server.tool(
        "analyze_nft_collection",
        {
            contractAddress: z.string().describe("NFT contract address")
        },
        async (args: { contractAddress: string }) => {
            try {
                const [name, symbol, totalSupply] = await Promise.all([
                    publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC721_ABI, functionName: 'name' }),
                    publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC721_ABI, functionName: 'symbol' }),
                    publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC721_ABI, functionName: 'totalSupply' }).catch(() => 'Unknown')
                ]);

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ“Š NFT Collection Analysis:\nðŸ·ï¸ Name: ${name}\nðŸŽ¯ Symbol: ${symbol}\nðŸ“ˆ Total Supply: ${totalSupply}\nðŸ“ Contract: ${args.contractAddress}\nðŸŒ Network: ${chain.name}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/token/${args.contractAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error analyzing collection: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );
}

async function addDeFiTools(server: any, walletClient: any, publicClient: any, chain: any, account: any) {
    // Token Price from Uniswap V3
    server.tool(
        "get_token_price_uniswap",
        {
            poolAddress: z.string().describe("Uniswap V3 pool address"),
            token0Address: z.string().optional().describe("Token0 address (optional)"),
            token1Address: z.string().optional().describe("Token1 address (optional)")
        },
        async (args: { poolAddress: string; token0Address?: string; token1Address?: string }) => {
            try {
                const [slot0, liquidity, token0, token1, fee] = await Promise.all([
                    publicClient.readContract({ address: args.poolAddress as `0x${string}`, abi: UNISWAP_V3_POOL_ABI, functionName: 'slot0' }),
                    publicClient.readContract({ address: args.poolAddress as `0x${string}`, abi: UNISWAP_V3_POOL_ABI, functionName: 'liquidity' }),
                    publicClient.readContract({ address: args.poolAddress as `0x${string}`, abi: UNISWAP_V3_POOL_ABI, functionName: 'token0' }),
                    publicClient.readContract({ address: args.poolAddress as `0x${string}`, abi: UNISWAP_V3_POOL_ABI, functionName: 'token1' }),
                    publicClient.readContract({ address: args.poolAddress as `0x${string}`, abi: UNISWAP_V3_POOL_ABI, functionName: 'fee' })
                ]);

                const sqrtPriceX96 = (slot0 as any)[0];
                const tick = (slot0 as any)[1];

                // Calculate price from sqrtPriceX96
                const price = (Number(sqrtPriceX96) / (2 ** 96)) ** 2;

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ’¹ Uniswap V3 Pool Info:\nðŸ’° Price: ${price.toFixed(8)}\nðŸ“Š Tick: ${tick}\nðŸ’§ Liquidity: ${liquidity}\nðŸª™ Token0: ${token0}\nðŸª™ Token1: ${token1}\nðŸ’¸ Fee: ${Number(fee) / 10000}%\nðŸ“ Pool: ${args.poolAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting pool info: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // ERC20 Token Analysis
    server.tool(
        "analyze_erc20_token",
        {
            tokenAddress: z.string().describe("ERC20 token address")
        },
        async (args: { tokenAddress: string }) => {
            try {
                const [name, symbol, decimals, totalSupply] = await Promise.all([
                    publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC20_ABI, functionName: 'name' }),
                    publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC20_ABI, functionName: 'symbol' }),
                    publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC20_ABI, functionName: 'decimals' }),
                    publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC20_ABI, functionName: 'totalSupply' })
                ]);

                const formattedSupply = formatUnits(totalSupply as bigint, decimals as number);

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸª™ ERC20 Token Analysis:\nðŸ·ï¸ Name: ${name}\nðŸŽ¯ Symbol: ${symbol}\nðŸ“ Decimals: ${decimals}\nðŸ“Š Total Supply: ${formattedSupply}\nðŸ“ Contract: ${args.tokenAddress}\nðŸŒ Network: ${chain.name}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/token/${args.tokenAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error analyzing token: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // DeFi Portfolio Tracker
    server.tool(
        "get_defi_portfolio",
        {
            address: z.string().optional().describe("Address to analyze (uses connected wallet if not provided)"),
            tokenAddresses: z.array(z.string()).optional().describe("Array of token addresses to check")
        },
        async (args: { address?: string; tokenAddresses?: string[] }) => {
            try {
                const targetAddress = (args.address || account.address) as `0x${string}`;
                const tokenAddresses = args.tokenAddresses || [];

                const nativeBalance = await publicClient.getBalance({ address: targetAddress });
                const portfolio = [`${chain.nativeCurrency.symbol}: ${formatEther(nativeBalance)}`];

                for (const tokenAddr of tokenAddresses) {
                    try {
                        const [balance, symbol, decimals] = await Promise.all([
                            publicClient.readContract({ address: tokenAddr as `0x${string}`, abi: ERC20_ABI, functionName: 'balanceOf', args: [targetAddress] }),
                            publicClient.readContract({ address: tokenAddr as `0x${string}`, abi: ERC20_ABI, functionName: 'symbol' }),
                            publicClient.readContract({ address: tokenAddr as `0x${string}`, abi: ERC20_ABI, functionName: 'decimals' })
                        ]);

                        const formattedBalance = formatUnits(balance as bigint, decimals as number);
                        portfolio.push(`${symbol}: ${formattedBalance}`);
                    } catch {
                        portfolio.push(`${tokenAddr}: Error reading balance`);
                    }
                }

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ“Š DeFi Portfolio:\nðŸ‘¤ Address: ${targetAddress}\nðŸ’° Holdings:\n${portfolio.map(p => `â€¢ ${p}`).join('\n')}\nðŸŒ Network: ${chain.name}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting portfolio: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );
}

async function addRWATools(server: any, walletClient: any, publicClient: any, chain: any, account: any) {
    // Mint ERC3643 Security Token (RWA)
    server.tool(
        "mint_erc3643_security_token",
        {
            tokenAddress: z.string().describe("ERC3643 security token address"),
            to: z.string().describe("Recipient address (must be verified)"),
            amount: z.string().describe("Amount to mint"),
            kycData: z.string().optional().describe("KYC verification data")
        },
        async (args: { tokenAddress: string; to: string; amount: string; kycData?: string }) => {
            try {
                // First check if recipient is verified
                const isVerified = await publicClient.readContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: ERC3643_ABI,
                    functionName: 'isVerified',
                    args: [args.to as `0x${string}`]
                });

                if (!isVerified) {
                    return {
                        content: [{
                            type: "text" as const,
                            text: `âŒ Security Token Mint Failed:\nðŸ‘¤ Recipient: ${args.to}\nðŸš« Status: Not KYC Verified\nðŸ’¡ The recipient must complete KYC/AML verification before receiving security tokens.`
                        }],
                        isError: true
                    };
                }

                const MINT_SECURITY_ABI = [
                    { name: "mint", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "to", type: "address" },
                        { name: "amount", type: "uint256" }
                    ], outputs: [] }
                ] as const;

                const hash = await walletClient.writeContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: MINT_SECURITY_ABI,
                    functionName: "mint",
                    args: [args.to as `0x${string}`, parseEther(args.amount)],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ›ï¸ Security Token Minted Successfully!\nðŸ“ Contract: ${args.tokenAddress}\nðŸ‘¤ To: ${args.to}\nðŸ’° Amount: ${args.amount}\nâœ… KYC Status: Verified\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error minting security token: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Mint Real Estate RWA Token
    server.tool(
        "mint_real_estate_rwa",
        {
            tokenAddress: z.string().describe("Real estate RWA token address"),
            to: z.string().describe("Recipient address"),
            propertyId: z.string().describe("Unique property identifier"),
            shares: z.string().describe("Number of shares to mint"),
            propertyValue: z.string().describe("Property valuation in USD"),
            propertyDetails: z.string().describe("Property details (JSON string)")
        },
        async (args: { tokenAddress: string; to: string; propertyId: string; shares: string; propertyValue: string; propertyDetails: string }) => {
            try {
                const MINT_REAL_ESTATE_ABI = [
                    { name: "mintPropertyShares", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "to", type: "address" },
                        { name: "propertyId", type: "bytes32" },
                        { name: "shares", type: "uint256" },
                        { name: "valuation", type: "uint256" },
                        { name: "metadata", type: "string" }
                    ], outputs: [] }
                ] as const;

                const propertyIdBytes = `0x${Buffer.from(args.propertyId).toString('hex').padEnd(64, '0')}` as `0x${string}`;

                const hash = await walletClient.writeContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: MINT_REAL_ESTATE_ABI,
                    functionName: "mintPropertyShares",
                    args: [
                        args.to as `0x${string}`,
                        propertyIdBytes,
                        BigInt(args.shares),
                        parseEther(args.propertyValue),
                        args.propertyDetails
                    ],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ˜ï¸ Real Estate RWA Minted!\nðŸ“ Contract: ${args.tokenAddress}\nðŸ‘¤ To: ${args.to}\nðŸ  Property ID: ${args.propertyId}\nðŸ“Š Shares: ${args.shares}\nðŸ’° Property Value: ${args.propertyValue}\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error minting real estate RWA: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Mint Commodity RWA Token
    server.tool(
        "mint_commodity_rwa",
        {
            tokenAddress: z.string().describe("Commodity RWA token address"),
            to: z.string().describe("Recipient address"),
            commodityType: z.enum(["gold", "silver", "oil", "wheat", "coffee", "other"]).describe("Commodity type"),
            quantity: z.string().describe("Quantity in standard units"),
            pricePerUnit: z.string().describe("Price per unit in USD"),
            storageLocation: z.string().describe("Storage/warehouse location"),
            certificationHash: z.string().optional().describe("Certification document hash")
        },
        async (args: { tokenAddress: string; to: string; commodityType: string; quantity: string; pricePerUnit: string; storageLocation: string; certificationHash?: string }) => {
            try {
                const MINT_COMMODITY_ABI = [
                    { name: "mintCommodity", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "to", type: "address" },
                        { name: "commodityType", type: "uint8" },
                        { name: "quantity", type: "uint256" },
                        { name: "pricePerUnit", type: "uint256" },
                        { name: "location", type: "string" },
                        { name: "certHash", type: "bytes32" }
                    ], outputs: [] }
                ] as const;

                const commodityTypeMap: { [key: string]: number } = {
                    gold: 0, silver: 1, oil: 2, wheat: 3, coffee: 4, other: 99
                };

                const certHash = args.certificationHash 
                    ? `0x${Buffer.from(args.certificationHash).toString('hex').padEnd(64, '0')}` as `0x${string}`
                    : '0x0000000000000000000000000000000000000000000000000000000000000000' as `0x${string}`;

                const hash = await walletClient.writeContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: MINT_COMMODITY_ABI,
                    functionName: "mintCommodity",
                    args: [
                        args.to as `0x${string}`,
                        commodityTypeMap[args.commodityType] || 99,
                        parseEther(args.quantity),
                        parseEther(args.pricePerUnit),
                        args.storageLocation,
                        certHash
                    ],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ—ï¸ Commodity RWA Minted!\nðŸ“ Contract: ${args.tokenAddress}\nðŸ‘¤ To: ${args.to}\nðŸ·ï¸ Commodity: ${args.commodityType.toUpperCase()}\nðŸ“Š Quantity: ${args.quantity}\nðŸ’° Price/Unit: ${args.pricePerUnit}\nðŸ“ Location: ${args.storageLocation}\n${args.certificationHash ? `ðŸ“‹ Cert Hash: ${args.certificationHash}\n` : ''}ðŸ”— Tx Hash: ${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error minting commodity RWA: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Mint Art & Collectibles RWA
    server.tool(
        "mint_art_collectible_rwa",
        {
            tokenAddress: z.string().describe("Art/Collectible RWA token address"),
            to: z.string().describe("Recipient address"),
            artworkTitle: z.string().describe("Artwork title"),
            artist: z.string().describe("Artist name"),
            appraisedValue: z.string().describe("Appraised value in USD"),
            authenticityProof: z.string().describe("Authenticity proof/certificate hash"),
            ipfsMetadata: z.string().describe("IPFS hash for artwork metadata and images")
        },
        async (args: { tokenAddress: string; to: string; artworkTitle: string; artist: string; appraisedValue: string; authenticityProof: string; ipfsMetadata: string }) => {
            try {
                const MINT_ART_ABI = [
                    { name: "mintArtwork", type: "function", stateMutability: "nonpayable", inputs: [
                        { name: "to", type: "address" },
                        { name: "title", type: "string" },
                        { name: "artist", type: "string" },
                        { name: "value", type: "uint256" },
                        { name: "proofHash", type: "bytes32" },
                        { name: "metadataURI", type: "string" }
                    ], outputs: [{ name: "tokenId", type: "uint256" }] }
                ] as const;

                const proofHash = `0x${Buffer.from(args.authenticityProof).toString('hex').padEnd(64, '0')}` as `0x${string}`;
                const metadataURI = `ipfs://${args.ipfsMetadata}`;

                const hash = await walletClient.writeContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: MINT_ART_ABI,
                    functionName: "mintArtwork",
                    args: [
                        args.to as `0x${string}`,
                        args.artworkTitle,
                        args.artist,
                        parseEther(args.appraisedValue),
                        proofHash,
                        metadataURI
                    ],
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸŽ¨ Art RWA Minted Successfully!\nðŸ“ Contract: ${args.tokenAddress}\nðŸ‘¤ To: ${args.to}\nðŸ–¼ï¸ Title: "${args.artworkTitle}"\nðŸ‘¨â€ðŸŽ¨ Artist: ${args.artist}\nðŸ’° Appraised Value: ${args.appraisedValue}\nðŸ“‹ Authenticity Proof: ${args.authenticityProof}\nðŸ”— Metadata: ${metadataURI}\nðŸ”— Tx Hash: ${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error minting art RWA: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Deploy RWA Token Contract
    server.tool(
        "deploy_rwa_token_contract",
        {
            tokenType: z.enum(["real_estate", "commodity", "art", "security", "infrastructure"]).describe("Type of RWA token"),
            name: z.string().describe("Token name"),
            symbol: z.string().describe("Token symbol"),
            totalSupply: z.string().describe("Total supply"),
            kycRequired: z.boolean().optional().describe("Whether KYC is required"),
            complianceModules: z.array(z.string()).optional().describe("Compliance module addresses")
        },
        async (args: { tokenType: string; name: string; symbol: string; totalSupply: string; kycRequired?: boolean; complianceModules?: string[] }) => {
            try {
                // For demo purposes, simulate contract deployment parameters
                const deploymentInfo = {
                    real_estate: {
                        features: ["Fractional Ownership", "Rental Income Distribution", "Property Management"],
                        compliance: ["SEC Regulation D", "Investor Accreditation", "Geographic Restrictions"]
                    },
                    commodity: {
                        features: ["Physical Asset Backing", "Storage Tracking", "Quality Certification"],
                        compliance: ["CFTC Regulations", "Warehouse Receipts", "Audit Requirements"]
                    },
                    art: {
                        features: ["Provenance Tracking", "Authenticity Verification", "Exhibition Rights"],
                        compliance: ["Anti-Money Laundering", "Cultural Heritage Laws", "Insurance Requirements"]
                    },
                    security: {
                        features: ["Dividend Distribution", "Voting Rights", "Transfer Restrictions"],
                        compliance: ["SEC Registration", "KYC/AML", "Investor Limits"]
                    },
                    infrastructure: {
                        features: ["Revenue Sharing", "Usage Tracking", "Maintenance Funding"],
                        compliance: ["Regulatory Approval", "Environmental Standards", "Public Interest"]
                    }
                };

                const info = deploymentInfo[args.tokenType as keyof typeof deploymentInfo];

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸš€ RWA Token Contract Deployment Plan:\n\nðŸ“‹ Token Details:\nâ€¢ Name: ${args.name}\nâ€¢ Symbol: ${args.symbol}\nâ€¢ Type: ${args.tokenType.replace('_', ' ').toUpperCase()}\nâ€¢ Total Supply: ${args.totalSupply}\nâ€¢ KYC Required: ${args.kycRequired ? 'Yes' : 'No'}\n\nðŸ”§ Features:\n${info.features.map(f => `â€¢ ${f}`).join('\n')}\n\nðŸ“œ Compliance Requirements:\n${info.compliance.map(c => `â€¢ ${c}`).join('\n')}\n\nðŸ’¡ Next Steps:\n1. Compile smart contract with required features\n2. Deploy to ${chain.name}\n3. Configure compliance modules\n4. Set up KYC/AML verification\n5. Register with relevant authorities\n\nâš ï¸ Note: Actual deployment requires legal compliance review and regulatory approval.`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error in RWA deployment planning: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // ERC3643 Security Token Tools (continued from previous)
    server.tool(
        "check_erc3643_compliance",
        {
            tokenAddress: z.string().describe("ERC3643 security token address"),
            userAddress: z.string().describe("User address to check compliance")
        },
        async (args: { tokenAddress: string; userAddress: string }) => {
            try {
                const [isVerified, identityRegistry, compliance] = await Promise.all([
                    publicClient.readContract({
                        address: args.tokenAddress as `0x${string}`,
                        abi: ERC3643_ABI,
                        functionName: 'isVerified',
                        args: [args.userAddress as `0x${string}`]
                    }),
                    publicClient.readContract({
                        address: args.tokenAddress as `0x${string}`,
                        abi: ERC3643_ABI,
                        functionName: 'identityRegistry'
                    }),
                    publicClient.readContract({
                        address: args.tokenAddress as `0x${string}`,
                        abi: ERC3643_ABI,
                        functionName: 'compliance'
                    })
                ]);

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ›ï¸ ERC3643 Compliance Check:\n${isVerified ? 'âœ…' : 'âŒ'} Verified: ${isVerified}\nðŸ†” Identity Registry: ${identityRegistry}\nðŸ“‹ Compliance Module: ${compliance}\nðŸ‘¤ User: ${args.userAddress}\nðŸª™ Token: ${args.tokenAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error checking compliance: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    server.tool(
        "check_transfer_eligibility",
        {
            tokenAddress: z.string().describe("ERC3643 token address"),
            from: z.string().describe("Sender address"),
            to: z.string().describe("Recipient address"),
            amount: z.string().describe("Transfer amount")
        },
        async (args: { tokenAddress: string; from: string; to: string; amount: string }) => {
            try {
                const canTransfer = await publicClient.readContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: ERC3643_ABI,
                    functionName: 'canTransfer',
                    args: [args.from as `0x${string}`, args.to as `0x${string}`, BigInt(args.amount)]
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ” Transfer Eligibility Check:\n${canTransfer ? 'âœ… Allowed' : 'âŒ Blocked'} Transfer Status: ${canTransfer}\nðŸ“¤ From: ${args.from}\nðŸ“¥ To: ${args.to}\nðŸ’° Amount: ${args.amount}\nðŸª™ Token: ${args.tokenAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error checking transfer eligibility: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // ERC6960 Dual Layer Token Tools
    server.tool(
        "get_erc6960_balances",
        {
            tokenAddress: z.string().describe("ERC6960 dual layer token address"),
            accountAddress: z.string().describe("Account address to check")
        },
        async (args: { tokenAddress: string; accountAddress: string }) => {
            try {
                const [balance, anchorBalance, totalAnchored] = await Promise.all([
                    publicClient.readContract({
                        address: args.tokenAddress as `0x${string}`,
                        abi: ERC6960_ABI,
                        functionName: 'balanceOf',
                        args: [args.accountAddress as `0x${string}`]
                    }),
                    publicClient.readContract({
                        address: args.tokenAddress as `0x${string}`,
                        abi: ERC6960_ABI,
                        functionName: 'anchorBalanceOf',
                        args: [args.accountAddress as `0x${string}`]
                    }),
                    publicClient.readContract({
                        address: args.tokenAddress as `0x${string}`,
                        abi: ERC6960_ABI,
                        functionName: 'totalAnchored'
                    })
                ]);

                return {
                    content: [{
                        type: "text" as const,
                        text: `âš–ï¸ ERC6960 Dual Layer Balances:\nðŸ’° Regular Balance: ${formatEther(balance as bigint)}\nâš“ Anchored Balance: ${formatEther(anchorBalance as bigint)}\nðŸ“Š Total Anchored (Global): ${formatEther(totalAnchored as bigint)}\nðŸ‘¤ Account: ${args.accountAddress}\nðŸª™ Token: ${args.tokenAddress}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting dual layer balances: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    server.tool(
        "anchor_erc6960_tokens",
        {
            tokenAddress: z.string().describe("ERC6960 token address"),
            amount: z.string().describe("Amount to anchor")
        },
        async (args: { tokenAddress: string; amount: string }) => {
            try {
                const hash = await walletClient.writeContract({
                    address: args.tokenAddress as `0x${string}`,
                    abi: ERC6960_ABI,
                    functionName: 'anchor',
                    args: [parseEther(args.amount)]
                });

                return {
                    content: [{
                        type: "text" as const,
                        text: `âš“ Tokens Anchored Successfully!\nðŸ’° Amount: ${args.amount}\nðŸ”— Tx Hash: ${hash}\nðŸª™ Token: ${args.tokenAddress}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error anchoring tokens: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // RWA Asset Tokenization Tools
    server.tool(
        "analyze_rwa_token",
        {
            tokenAddress: z.string().describe("RWA token address"),
            tokenStandard: z.enum(["ERC20", "ERC721", "ERC1155", "ERC3643", "ERC6960"]).describe("Token standard")
        },
        async (args: { tokenAddress: string; tokenStandard: string }) => {
            try {
                let analysis = `ðŸ¢ RWA Token Analysis:\nðŸ“ Contract: ${args.tokenAddress}\nðŸ“‹ Standard: ${args.tokenStandard}\nðŸŒ Network: ${chain.name}\n`;

                if (args.tokenStandard === "ERC3643") {
                    try {
                        const [identityRegistry, compliance] = await Promise.all([
                            publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC3643_ABI, functionName: 'identityRegistry' }),
                            publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC3643_ABI, functionName: 'compliance' })
                        ]);
                        analysis += `\nðŸ”’ Security Token Features:\nâ€¢ Identity Registry: ${identityRegistry}\nâ€¢ Compliance Module: ${compliance}\nâ€¢ KYC/AML Required: Yes\nâ€¢ Transfer Restrictions: Yes`;
                    } catch {}
                }

                if (args.tokenStandard === "ERC6960") {
                    try {
                        const totalAnchored = await publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC6960_ABI, functionName: 'totalAnchored' });
                        analysis += `\nâš–ï¸ Dual Layer Features:\nâ€¢ Total Anchored: ${formatEther(totalAnchored as bigint)}\nâ€¢ Anchor/Weigh Mechanism: Available\nâ€¢ Yield Generation: Potential`;
                    } catch {}
                }

                analysis += `\n\nðŸ’¡ RWA Use Cases:\nâ€¢ Real Estate Tokenization\nâ€¢ Commodity Tokenization\nâ€¢ Securities & Bonds\nâ€¢ Art & Collectibles\nâ€¢ Infrastructure Assets\n\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/token/${args.tokenAddress}`;

                return { content: [{ type: "text" as const, text: analysis }] };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error analyzing RWA token: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );
}ðŸ”— Tx Hash: ${hash}\nðŸª™ Token: ${args.tokenAddress}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error anchoring tokens: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // RWA Asset Tokenization Tools
    server.tool(
        "analyze_rwa_token",
        {
            tokenAddress: z.string().describe("RWA token address"),
            tokenStandard: z.enum(["ERC20", "ERC721", "ERC1155", "ERC3643", "ERC6960"]).describe("Token standard")
        },
        async (args: { tokenAddress: string; tokenStandard: string }) => {
            try {
                let analysis = `ðŸ¢ RWA Token Analysis:\nðŸ“ Contract: ${args.tokenAddress}\nðŸ“‹ Standard: ${args.tokenStandard}\nðŸŒ Network: ${chain.name}\n`;

                if (args.tokenStandard === "ERC3643") {
                    try {
                        const [identityRegistry, compliance] = await Promise.all([
                            publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC3643_ABI, functionName: 'identityRegistry' }),
                            publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC3643_ABI, functionName: 'compliance' })
                        ]);
                        analysis += `\nðŸ”’ Security Token Features:\nâ€¢ Identity Registry: ${identityRegistry}\nâ€¢ Compliance Module: ${compliance}\nâ€¢ KYC/AML Required: Yes\nâ€¢ Transfer Restrictions: Yes`;
                    } catch {}
                }

                if (args.tokenStandard === "ERC6960") {
                    try {
                        const totalAnchored = await publicClient.readContract({ address: args.tokenAddress as `0x${string}`, abi: ERC6960_ABI, functionName: 'totalAnchored' });
                        analysis += `\nâš–ï¸ Dual Layer Features:\nâ€¢ Total Anchored: ${formatEther(totalAnchored as bigint)}\nâ€¢ Anchor/Weigh Mechanism: Available\nâ€¢ Yield Generation: Potential`;
                    } catch {}
                }

                analysis += `\n\nðŸ’¡ RWA Use Cases:\nâ€¢ Real Estate Tokenization\nâ€¢ Commodity Tokenization\nâ€¢ Securities & Bonds\nâ€¢ Art & Collectibles\nâ€¢ Infrastructure Assets\n\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/token/${args.tokenAddress}`;

                return { content: [{ type: "text" as const, text: analysis }] };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error analyzing RWA token: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );
}

async function addAdvancedTokenTools(server: any, walletClient: any, publicClient: any, chain: any, account: any) {
    // Multi-standard token detector
    server.tool(
        "detect_token_standard",
        {
            contractAddress: z.string().describe("Contract address to analyze")
        },
        async (args: { contractAddress: string }) => {
            try {
                const standards: string[] = [];
                const features: string[] = [];

                // Check ERC20
                try {
                    await publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC20_ABI, functionName: 'totalSupply' });
                    standards.push("ERC20");
                    features.push("Fungible Token");
                } catch {}

                // Check ERC721
                try {
                    await publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC721_ABI, functionName: 'name' });
                    standards.push("ERC721");
                    features.push("Non-Fungible Token (NFT)");
                } catch {}

                // Check ERC1155
                try {
                    await publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC1155_ABI, functionName: 'uri', args: [1n] });
                    standards.push("ERC1155");
                    features.push("Multi-Token Standard");
                } catch {}

                // Check ERC3643
                try {
                    await publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC3643_ABI, functionName: 'identityRegistry' });
                    standards.push("ERC3643");
                    features.push("Security Token (T-REX)");
                } catch {}

                // Check ERC6960
                try {
                    await publicClient.readContract({ address: args.contractAddress as `0x${string}`, abi: ERC6960_ABI, functionName: 'totalAnchored' });
                    standards.push("ERC6960");
                    features.push("Dual Layer Token");
                } catch {}

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸ” Token Standard Detection:\nðŸ“ Contract: ${args.contractAddress}\nðŸ“‹ Standards: ${standards.length > 0 ? standards.join(', ') : 'None detected'}\nðŸŽ¯ Features: ${features.length > 0 ? features.join(', ') : 'Standard contract'}\nðŸŒ Network: ${chain.name}\n\n${standards.length === 0 ? 'âŒ No recognized token standards found' : 'âœ… Token standards detected successfully'}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error detecting standards: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Advanced contract interaction
    server.tool(
        "call_contract_function",
        {
            contractAddress: z.string().describe("Contract address"),
            functionName: z.string().describe("Function name to call"),
            functionAbi: z.string().describe("Function ABI as JSON string"),
            args: z.array(z.any()).optional().describe("Function arguments array"),
            isWriteFunction: z.boolean().optional().describe("Whether this is a write function (requires gas)")
        },
        async (args: { contractAddress: string; functionName: string; functionAbi: string; args?: any[]; isWriteFunction?: boolean }) => {
            try {
                const abi = JSON.parse(args.functionAbi);
                const contractArgs = args.args || [];

                if (args.isWriteFunction) {
                    const hash = await walletClient.writeContract({
                        address: args.contractAddress as `0x${string}`,
                        abi: [abi],
                        functionName: args.functionName,
                        args: contractArgs,
                    });

                    return {
                        content: [{
                            type: "text" as const,
                            text: `ðŸ”§ Contract Write Function Called:\nðŸ“ Contract: ${args.contractAddress}\nâš™ï¸ Function: ${args.functionName}\nðŸ”— Tx Hash: ${hash}\nðŸ” Explorer: ${chain.blockExplorers?.default?.url}/tx/${hash}`
                        }]
                    };
                } else {
                    const result = await publicClient.readContract({
                        address: args.contractAddress as `0x${string}`,
                        abi: [abi],
                        functionName: args.functionName,
                        args: contractArgs,
                    });

                    return {
                        content: [{
                            type: "text" as const,
                            text: `ðŸ” Contract Read Function Result:\nðŸ“ Contract: ${args.contractAddress}\nâš™ï¸ Function: ${args.functionName}\nðŸ“Š Result: ${JSON.stringify(result, null, 2)}`
                        }]
                    };
                }
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error calling contract function: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Cross-chain asset bridge detector
    server.tool(
        "detect_bridged_assets",
        {
            tokenAddresses: z.array(z.string()).describe("Array of token addresses to check for bridge patterns")
        },
        async (args: { tokenAddresses: string[] }) => {
            try {
                const bridgePatterns: { [key: string]: string[] } = {};

                for (const tokenAddr of args.tokenAddresses) {
                    try {
                        const [name, symbol] = await Promise.all([
                            publicClient.readContract({ address: tokenAddr as `0x${string}`, abi: ERC20_ABI, functionName: 'name' }),
                            publicClient.readContract({ address: tokenAddr as `0x${string}`, abi: ERC20_ABI, functionName: 'symbol' })
                        ]);

                        const patterns = [];
                        const nameStr = String(name).toLowerCase();
                        const symbolStr = String(symbol).toLowerCase();

                        if (nameStr.includes('wrapped') || symbolStr.startsWith('w')) patterns.push('Wrapped Asset');
                        if (nameStr.includes('bridged') || nameStr.includes('bridge')) patterns.push('Bridge Token');
                        if (symbolStr.includes('.e') || symbolStr.includes('av')) patterns.push('Avalanche Bridge');
                        if (symbolStr.includes('poly') || nameStr.includes('polygon')) patterns.push('Polygon Bridge');
                        if (nameStr.includes('arbitrum') || symbolStr.includes('arb')) patterns.push('Arbitrum Bridge');
                        if (nameStr.includes('optimism') || symbolStr.includes('op')) patterns.push('Optimism Bridge');

                        if (patterns.length > 0) {
                            bridgePatterns[tokenAddr] = patterns;
                        }
                    } catch {}
                }

                const analysis = Object.entries(bridgePatterns).map(([addr, patterns]) => 
                    `â€¢ ${addr}: ${patterns.join(', ')}`
                ).join('\n');

                return {
                    content: [{
                        type: "text" as const,
                        text: `ðŸŒ‰ Bridge Asset Detection:\n${analysis.length > 0 ? analysis : 'âŒ No bridge patterns detected'}\n\nðŸ” Checked ${args.tokenAddresses.length} tokens\nðŸŒ Network: ${chain.name}`
                    }]
                };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error detecting bridge assets: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );

    // Advanced portfolio analytics
    server.tool(
        "get_advanced_portfolio_analytics",
        {
            address: z.string().optional().describe("Address to analyze"),
            includeNFTs: z.boolean().optional().describe("Include NFT analysis"),
            includeDeFi: z.boolean().optional().describe("Include DeFi position analysis")
        },
        async (args: { address?: string; includeNFTs?: boolean; includeDeFi?: boolean }) => {
            try {
                const targetAddress = (args.address || account.address) as `0x${string}`;
                let analytics = `ðŸ“Š Advanced Portfolio Analytics:\nðŸ‘¤ Address: ${targetAddress}\nðŸŒ Network: ${chain.name}\n\n`;

                // Basic balance
                const nativeBalance = await publicClient.getBalance({ address: targetAddress });
                analytics += `ðŸ’° Native Balance: ${formatEther(nativeBalance)} ${chain.nativeCurrency.symbol}\n`;

                // Transaction count (activity indicator)
                const txCount = await publicClient.getTransactionCount({ address: targetAddress });
                analytics += `ðŸ“Š Transaction Count: ${txCount}\n`;
                analytics += `ðŸŽ¯ Activity Level: ${txCount > 1000 ? 'Very High' : txCount > 100 ? 'High' : txCount > 10 ? 'Medium' : 'Low'}\n\n`;

                if (args.includeNFTs) {
                    analytics += `ðŸ–¼ï¸ NFT Analysis:\nâ€¢ Requires specific NFT contract addresses for detailed analysis\nâ€¢ Use 'get_nft_balance' for specific collections\n\n`;
                }

                if (args.includeDeFi) {
                    analytics += `ðŸ’¹ DeFi Analysis:\nâ€¢ Requires token contract addresses for detailed analysis\nâ€¢ Use 'get_defi_portfolio' with token addresses\nâ€¢ Check for LP tokens, staking positions, and yield farming\n\n`;
                }

                analytics += `ðŸ” Explorer: ${chain.blockExplorers?.default?.url}/address/${targetAddress}`;

                return { content: [{ type: "text" as const, text: analytics }] };
            } catch (error) {
                return { content: [{ type: "text" as const, text: `Error getting analytics: ${error instanceof Error ? error.message : String(error)}` }], isError: true };
            }
        }
    );
}

// Setup tools and start server
async function main() {
    await setupAdvancedEVMv3Tools();
    
    const transport = new StdioServerTransport();
    await server.connect(transport);
    
    console.log("Advanced EVM MCP Server v3 is running...");
}

// Handle graceful shutdown
process.on('SIGINT', () => {
    console.log('Shutting down Advanced EVM MCP Server v3...');
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('Shutting down Advanced EVM MCP Server v3...');
    process.exit(0);
});

main().catch((error) => {
    console.error("Failed to start Advanced EVM MCP Server v3:", error);
    process.exit(1);
});